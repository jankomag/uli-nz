?jarque.bera.test(data)
#### 2) fitting and forecasting from ARMA models
a1 <- arima(data, order = c(1,0,1))
predict(a1, 5)
#test for serial correlation
resi <- a1$residuals
Box.test(resi, type="Ljung-Box", lag=20)
tsdiag(a1, gof=20)
#finding a suitable ARMA model
#choosing a more appropriate model among candidate model
acf(resi, lag=10)
pacf(resi, lag=10)
####3) fitting and forecasting from GARCH models
garch11.spec = ugarchspec(variance.model = list(garchOrder=c(1,1)),
mean.model = list(armaOrder=c(0,0)))
SNP.garch11.fit = ugarchfit(spec=garch11.spec, data=SNP.rtn)
persistence(SNP.garch11.fit)
SNP.garch11.fit = ugarchfit(spec=garch11.spec, data=resi)
SNP.garch11.fit = ugarchfit(spec=garch11.spec, data=resisq)
####1) descriptive statistics of returns (mean, var, skewness, kurtosis, testing fo normality, etc
mean(data)
var(data)
library(quantmod)
library(PerformanceAnalytics)
library(tseries)
library(rugarch)
library(car)
getSymbols("AAPL")
### Exam Script
?adf.test()
#1 a)
getSymbols("TSLA", from="2010-06-29", to="2020-12-30")
rtn <- diff(log(TSLA$TSLA.Close))
skewness(rtn)
View(TSLA)
View(rtn)
rtn <- rtn[-1]
skewness(rtn)
jarque.bera.test(rtn)
?jarque.bera.test(rtn)
# c)
?Box.test(rtn, lag = 10, type="Lj")
# c)
Box.test(rtn, lag = 10, type="Lj") # independce null
# d)
acf(rtn)
arma00 <- arima(rtn, order=c(0,0,0))
# d)
pacf(rtn)
# e)
predict(arma00, 1)
# e)
predict(arma00, 2)
# e)
predict(arma00, 1)
# f)
rtn.sq <- rtn^2
jarque.bera.test(rtn.sq)
Box.test(rtn.sq, lag = 10, type="Lj") # evidence for no serial correlation
?Box.test(rtn.sq, lag = 10, type="Lj") # evidence for serial correlation
pacf(rtn.sq)
pacf(rtn.sq, plot = FALSE)
# h)
garchspec11 <- ugarchspec(variance.model = list(garchOrder=c(1,1)))
garchfit11 <- ugarchfit(spec = garchspec11)
View(rtn.sq)
rtn <- rtn[2:length(rtn)]
skewness(rtn) #[1] -0.03350531
# b) #reject normality
jarque.bera.test(rtn)
# c)
Box.test(rtn, lag = 10, type="Lj") # evidence for no serial correlation
# d)
pacf(rtn)
arma00 <- arima(rtn, order=c(0,0,0))
# e)
predict(arma00, 1) # prediction = 0.001867342
# f)
rtn.sq <- rtn^2
?Box.test(rtn.sq, lag = 10, type="Lj") # evidence for serial correlation
Box.test(rtn.sq, lag = 10, type="Lj") # evidence for serial correlation
adf.test(rtn.sq)
# g)
pacf(rtn.sq, plot = FALSE) #0.035
# h)
garchspec11 <- ugarchspec(variance.model = list(garchOrder=c(1,1)))
garchfit11 <- ugarchfit(spec = garchspec11)
garchfit11 <- ugarchfit(spec = garchspec11, data=rtn)
garchfit11 <- ugarchfit(spec = garchspec11, data=rtn.sq)
garchfit11
coef(garchfit11)
# h)
garchspec11 <- ugarchspec(variance.model = list(garchOrder=c(1,1)), mean.model = list(armaOrder=c(0,0)))
garchfit11 <- ugarchfit(spec = garchspec11, data=rtn.sq)
coef(garchfit11)
# h)
garchspec22 <- ugarchspec(variance.model = list(garchOrder=c(2,2)), mean.model = list(armaOrder=c(0,0)))
garchfit11 <- ugarchfit(spec = garchspec11, data=rtn.sq)
infocriteria(garchfit11)
# h)
garchspec11 <- ugarchspec(variance.model = list(garchOrder=c(1,1)), mean.model = list(armaOrder=c(0,0)))
garchfit11 <- ugarchfit(spec = garchspec11, data=rtn.sq)
coef(garchfit11)
infocriteria(garchfit11)
# h)
garchspec22 <- ugarchspec(variance.model = list(garchOrder=c(2,2)), mean.model = list(armaOrder=c(0,0)))
garchfit22 <- ugarchfit(spec = garchspec22, data=rtn.sq)
infocriteria(garchfit22)
garchfit22
garchfit11
# h)
garchspec22 <- ugarchspec(variance.model = list(garchOrder=c(2,1)), mean.model = list(armaOrder=c(0,0)))
garchfit22 <- ugarchfit(spec = garchspec22, data=rtn.sq)
garchfit22
# h)
garchspec22 <- ugarchspec(variance.model = list(garchOrder=c(2,2)), mean.model = list(armaOrder=c(0,0)))
garchfit22 <- ugarchfit(spec = garchspec22, data=rtn.sq)
garchfit22
# h)
garchspec22 <- ugarchspec(variance.model = list(garchOrder=c(1,2)), mean.model = list(armaOrder=c(0,0)))
garchfit22 <- ugarchfit(spec = garchspec22, data=rtn.sq)
garchfit22
coef(garchfit11)
#1 a)
getSymbols("TSLA", from="2010-06-29", to="2020-12-30")
rtn <- diff(log(TSLA$TSLA.Close))
rtn <- rtn[-1]
#rtn <- rtn[2:length(rtn)]
skewness(rtn) #[1] -0.03350531
# b) #reject normality
jarque.bera.test(rtn)
# c)
Box.test(rtn, lag = 10, type="Lj") # evidence for no serial correlation
# d)
pacf(rtn)
arma00 <- arima(rtn, order=c(0,0,0))
# e)
predict(arma00, 1) # prediction = 0.001867342
# g)
pacf(rtn.sq, plot = FALSE) #0.035
# h)
garchspec11 <- ugarchspec(variance.model = list(garchOrder=c(1,1)), mean.model = list(armaOrder=c(0,0)))
garchfit11 <- ugarchfit(spec = garchspec11, data=rtn.sq)
garchfit11
coef(garchfit11)
Box.test(rtn.sq, lag = 10, type="Ljung-box") # evidence for serial correlation
Box.test(rtn.sq, lag = 10, type="Ljung-Box") # evidence for serial correlation
pnorm(1.5)
pnorm(0.5)
pnorm(0.15)
pnorm(0.05)
qnorm(0.01)
?qnorm(0.01)
pnorm(0.01)
pnorm(0.05)
qnorm(0.05)
pnorm(2.3)
pnorm(1.64)
pnorm(1.96)
pnorm(10)
pnorm(7)
pnorm(4)
pnorm(0.53)
garch11 <- ?ugarchspec(variance.model = list(model = "iGARCH", garchOrder=c(1,1)))
?ugarchspec
garch11 <- ?ugarchspec(variance.model = list(model = "iGARCH", garchOrder=c(1,1)), distribution.model="norm")
garch11 <- ugarchspec(variance.model = list(model = "iGARCH", garchOrder = c(1,1)), distribution.model="norm")
fitgarch11 <- ugarchfit(spec = garch11, data=rtn)
fitgarch11
# b)
garch11_gau <- ugarchspec(variance.model = list(model = "iGARCH", garchOrder = c(1,1)),
mean.model = list(armaOrder=c(0,0)),
distribution.model="norm")
fitgarch11_gau <- ugarchfit(spec = garch11_gau, data=rtn)
fitgarch11_gau
head(sigma(fitgarch11_gau))
head(fitted(SNP.garch11.f))
head(fitted(fitgarch11_gau))
len(rtn)
length(rtn)
tail(sigma(fitgarch11_gau))
exp(-0.1042798)-1
# c)
garch11_std <- ugarchspec(variance.model = list(model = "iGARCH", garchOrder = c(1,1)),
mean.model = list(armaOrder=c(0,0)),
distribution.model="std")
fitgarch11_std <- ugarchfit(spec = garch11_std, data=rtn)
fitgarch11_std
fitted(fitgarch11_std)
tail(fitted(fitgarch11_std))
tail(sigma(fitgarch11_std))
pnorm(0.01)
pnorm(0.85412668)
# load the packages
library(sf)
library(tmap)
download.file("https://archive.researchdata.leeds.ac.uk/741/1/ch7.Rdata",
"./wk1.RData", mode = "wb")
load("wk1.RData")
# look at the structure
str(oa)
str(lsoa)
# examine the first 6 rows
head(properties)
# create a data frame version
props = data.frame(properties)
# check the names of the attributes
names(props)
props = props[, -41]
# remove the properties and lsoa layers
rm(list = c("lsoa", "properties"))
properties = st_as_sf(props, coords = c("Lon", "Lat"), crs = 4326)
tm_shape(properties) +
tm_dots("Price", size = 0.1,alpha = 0.5,
style = "kmeans",
palette = "inferno") +
tm_layout(bg.color = "grey95",
legend.position = c("right", "top"),
legend.outside = T)
# set tmap mode for interactive plots
tmap_mode("view")
# create the plot
tm_shape(properties) +
tm_dots("Price", size=0.1, alpha = 0.5,
style = "kmeans",
palette = "viridis") +
tm_basemap("OpenStreetMap")
tmap_mode("plot")
##task1
tmap_mode("view")
tm_shape(properties) +
tm_dots("Beds", size=0.1, alpha = 0.5,
style = "kmeans",
palette = "viridis") +
tm_basemap("OpenStreetMap")
# plot the areas
tm_shape(oa) +
tm_borders(col = "black", lwd = 0.1) +
# add the points
tm_shape(properties) +
tm_dots(col = "#FB6A4A") +
# define some style / plotting options
tm_layout(frame = F)
properties = st_transform(properties, 27700)
properties_filt
selected_oa <- oa[oa$code == "E00033902"]
oa
selected_oa <- oa$code == "E00033902"
oa
selected_oa
tm_shape(selected_oa) +
tm_fill() +
tm_shape(prop_clip) +
tm_dots()
prop_clip = properties[oa,]
tm_shape(selected_oa) +
tm_fill() +
tm_shape(prop_clip) +
tm_dots()
properties = st_transform(properties, 27700)
properties_filt
prop_clip = properties[oa,]
selected_oa <- filter(oa, code == "E00033902")
selected_oa <- filter(oa, oa$code == "E00033902")
selected_oa <- oa[oa$code == "E00033902",]
selected_oa
tm_shape(selected_oa) +
tm_fill() +
tm_shape(prop_clip) +
tm_dots()
selected_oa <- oa[oa$code == "E00033902",]
prop_sel_clip = properties[selected_oa,]
tm_shape(selected_oa) +
tm_fill() +
tm_shape(prop_clip) +
tm_dots()
selected_oa <- oa[oa$code == "E00033902",]
prop_select_int <- st_intersection(selected_oa, properties)
tm_shape(selected_oa) +
tm_fill() +
tm_shape(prop_clip) +
tm_dots()
# continued
# union the oa layer to a single polygon
liv_merge <- st_sf(st_union(oa))
# buffer this
buf_liv <- st_buffer(liv_merge, 2000)
# and map
tm_shape(buf_liv) +
tm_borders() +
tm_shape(liv_merge) + tm_fill()
tmp = st_contains(oa, properties, sparse = F)
prop.count = rowSums(tmp)
head(prop.count)
oa$prop.count = prop.count
tm_shape(oa) +
tm_dots(size = "prop.count", alpha = 0.5) +
tm_shape(liv_merge) + tm_borders()
st_crs(oa)
st_crs(selected_oa)
head(st_area(oa))
head(st_area(selected_oa))
#### TASK 3
oa$area_sqkm <- st_area(oa) / (1000 * 1000)
oa(head)
head(oa)
oa$props_per_sqkm <- oa$prop.count/ oa$area_sqkm
head(oa)
tm_shape(oa) +
tm_fill(col = oa$props_per_sqkm)
tm_shape(selected_oa) +
tm_fill() +
tm_shape(prop_clip) +
tm_dots()
tm_shape(oa) +
tm_fill() +
tm_dots()
tm_shape(oa) +
tm_fill() +
tm_shape(oa) +
tm_fill(col = oa$props_per_sqkm)
tm_shape(oa) +
tm_fill(col ="props_per_sqkm")
tm_shape(oa) +
tm_fill(col ="props_per_sqkm", style = "kmeans")
# continued
## define a 1km grid in polygons
sq = st_make_grid(oa, 1000, what = "polygons", square = T)
sq_grid = data.frame(ID = 1:length(sq))
st_geometry(sq_grid) = sq
# clip the extent of oa
sq_grid = sq_grid[oa,]
# plot
tm_shape(sq_grid) + tm_polygons(col = "grey") +
tm_shape(oa) +tm_borders(col = "red")
int.res_sf <- st_intersection(sq_grid, oa[, c("code","prop.count")])
head(int.res_sf)
# generate area and proportions
int.areas <- st_area(int.res_sf)
liv.areas <- st_area(oa)
# match tract area to the new layer
index <- match(int.res_sf$code, oa$code)
liv.areas <- liv.areas[index]
liv.prop <- as.vector(int.areas)/as.vector(liv.areas)
int.res_sf$props <- oa$prop.count[index] * liv.prop
# summarise the counts of properties of the grid cells
int.res_sf %>% st_drop_geometry() %>%
group_by(ID) %>%
summarise(count = sum(props)) -> props
# link to the grid data
sq_grid %>% left_join(props) -> sq_grid
library(dplyr)
# summarise the counts of properties of the grid cells
int.res_sf %>% st_drop_geometry() %>%
group_by(ID) %>%
summarise(count = sum(props)) -> props
# link to the grid data
sq_grid %>% left_join(props) -> sq_grid
# link to the grid data
sq_grid %>% left_join(props) -> sq_grid
tm_shape(sq_grid) +
tm_polygons("count", palette = "Greens",
style = "kmeans", title = "Properties for sale") +
tm_layout(frame = F, legend.position = c(1,0.5))
tm_shape(props2) +
tm_polygons("prop.count", palette = "Greens",
style = "kmeans", title = "No. of Properties for sale") +
tm_layout(frame = F, legend.position = c(1,0.5))
# link to the grid data
sq_grid %>% left_join(props) -> sq_grid
tm_shape(sq_grid) +
tm_polygons("count", palette = "Greens",
style = "kmeans", title = "Properties for sale") +
tm_layout(frame = F, legend.position = c(1,0.5))
props2 = st_interpolate_aw(oa[, "prop.count"], sq_grid, extensive = T)
tm_shape(props2) +
tm_polygons("prop.count", palette = "Greens",
style = "kmeans", title = "No. of Properties for sale") +
tm_layout(frame = F, legend.position = c(1,0.5))
gc()
#### Data imports ####
sa1 <- st_read("data/geographic/auckland_urban_centroid_sa1.gpkg")
households <- read.csv("data/geographic/SA1 Census 2018-WellingtonRegion_updated_4-11-21/households_in_sa1s.csv")
dampness <- read.csv("data/geographic/SA1 Census 2018-WellingtonRegion_updated_4-11-21/dampness.csv")
stations <- st_read("data/transport/public_transport/trains_auckland.gpkg")
#transforming to the same coordinate system
stations <- st_transform(stations, 27291)
sa1 = st_transform(sa1, 27291)
# load the packages
library(sf)
library(sp)
library(tmap)
library(dplyr)
library(ggplot2)
library(RColorBrewer)
#### Data imports ####
sa1 <- st_read("data/geographic/auckland_urban_centroid_sa1.gpkg")
setwd("~/Desktop/jan nie bałagani/all things uni/Dissertation/uli-nz")
#### Data imports ####
sa1 <- st_read("data/geographic/auckland_urban_centroid_sa1.gpkg")
households <- read.csv("data/geographic/SA1 Census 2018-WellingtonRegion_updated_4-11-21/households_in_sa1s.csv")
dampness <- read.csv("data/geographic/SA1 Census 2018-WellingtonRegion_updated_4-11-21/dampness.csv")
stations <- st_read("data/transport/public_transport/trains_auckland.gpkg")
#transforming to the same coordinate system
stations <- st_transform(stations, 27291)
sa1 = st_transform(sa1, 27291)
sa1$distance_to_station <- st_nearest_points(sa1, stations, unit = "m")
#tm_shape(pt) +
#tm_dots(col="Mode")
#### Station distances ####
sa1$distance_to_station <- st_nearest_feature(sa1, stations, unit = "m")
#tm_shape(pt) +
#tm_dots(col="Mode")
#### Station distances ####
sa1$distance_to_station <- st_nearest_feature(sa1, stations)
summary(sa1)
tm_shape(sa1) +
tm_dots(col="distance_to_station",
style = "kmeans", palette = "Blues") +
tm_shape(stations) +
tm_dots(col="red")
tm_shape(sa1) +
tm_dots(col="distance_to_station",
style = "kmeans") +
tm_shape(stations) +
tm_dots(col="red")
tm_shape(sa1) +
tm_dots(col="distance_to_station") +
tm_shape(stations) +
tm_dots(col="red")
st_distance(sa1, sa1[st_nearest_feature], by_element = TRUE)
st_distance(sa1, stations[st_nearest_feature], by_element = TRUE)
summary(sa1)
sa1$dist_nearest_station <- st_distance(sa1, stations[st_nearest_feature], by_element = TRUE)
#### Data imports ####
sa1 <- st_read("data/geographic/auckland_urban_centroid_sa1.gpkg")
households <- read.csv("data/geographic/SA1 Census 2018-WellingtonRegion_updated_4-11-21/households_in_sa1s.csv")
dampness <- read.csv("data/geographic/SA1 Census 2018-WellingtonRegion_updated_4-11-21/dampness.csv")
stations <- st_read("data/transport/public_transport/trains_auckland.gpkg")
#transforming to the same coordinate system
stations <- st_transform(stations, 27291)
sa1 = st_transform(sa1, 27291)
#tm_shape(pt) +
#tm_dots(col="Mode")
#### Station distances ####
sa1$nearest_station <- st_nearest_feature(sa1, stations)
sa1$dist_nearest_station <- st_distance(sa1, stations[st_nearest_feature], by_element = TRUE)
sa1$dist_nearest_station <- st_distance(sa1, stations[st_nearest_feature], by_element = FALSE)
sa1$dist_nearest_station <- st_distance(sa1, stations[sa1$nearest_station], by_element = FALSE)
summary(sa1)
sa1$dist_nearest_station <- st_distance(sa1, stations[sa1$nearest_station], by_element = TRUE)
tm_shape(sa1) +
tm_dots(col="distance_to_station") +
tm_shape(stations) +
tm_dots(col="black")
summary(sa1)
tm_shape(sa1) +
tm_dots(col="dist_nearest_station") +
tm_shape(stations) +
tm_dots(col="black")
sa1$dist_nearest_station <- st_distance(sa1$nearest_station, station by_element = TRUE)
sa1$dist_nearest_station <- st_distance(sa1$nearest_station, station, by_element = TRUE)
sa1$dist_nearest_station <- st_distance(sa1, station, by_element = TRUE)
sa1$dist_nearest_station <- st_distance(sa1, stations, by_element = TRUE)
summary(sa1)
tm_shape(sa1) +
tm_dots(col="dist_nearest_station") +
tm_shape(stations) +
tm_dots(col="black")
sa1$dist_nearest_station <- st_distance(sa1, stations, by_element = FALSE)
summary(sa1)
tm_shape(sa1) +
tm_dots(col="dist_nearest_station") +
tm_shape(stations) +
tm_dots(col="black")
sa1$dist_nearest_station <- st_distance(sa1, stations, by_element = TRUE)
summary(sa1)
tm_shape(sa1) +
tm_dots(col="dist_nearest_station") +
tm_shape(stations) +
tm_dots(col="black")
tm_shape(sa1) +
tm_dots(col="dist_nearest_station", style="kmeans") +
tm_shape(stations) +
tm_dots(col="black")
tm_shape(sa1) +
tm_dots(col="dist_nearest_station", style="kmeans", aplette="-reds") +
tm_shape(stations) +
tm_dots(col="black")
tm_shape(sa1) +
tm_dots(col="dist_nearest_station", style="kmeans", palette=-"reds") +
tm_shape(stations) +
tm_dots(col="black")
tm_shape(sa1) +
tm_dots(col="dist_nearest_station", style="kmeans", palette="-reds") +
tm_shape(stations) +
tm_dots(col="black")
tm_shape(sa1) +
tm_dots(col="dist_nearest_station", style="kmeans", palette="blues") +
tm_shape(stations) +
tm_dots(col="black")
tmap_mode("plot")
tm_shape(sa1) +
tm_dots(col="dist_nearest_station", style="kmeans") +
tm_shape(stations) +
tm_dots(col="black")
tmap_mode("view")
tm_shape(sa1) +
tm_dots(col="dist_nearest_station", style="kmeans") +
tm_shape(stations) +
tm_dots(col="black")
summary(sa1)
